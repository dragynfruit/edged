// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod platforms {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod darwinn {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DESCRIPTION: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DESCRIPTION: i16 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DESCRIPTION: [Description; 4] = [
  Description::BASE_ADDRESS_OUTPUT_ACTIVATION,
  Description::BASE_ADDRESS_INPUT_ACTIVATION,
  Description::BASE_ADDRESS_PARAMETER,
  Description::BASE_ADDRESS_SCRATCH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Description(pub i16);
#[allow(non_upper_case_globals)]
impl Description {
  pub const BASE_ADDRESS_OUTPUT_ACTIVATION: Self = Self(0);
  pub const BASE_ADDRESS_INPUT_ACTIVATION: Self = Self(1);
  pub const BASE_ADDRESS_PARAMETER: Self = Self(2);
  pub const BASE_ADDRESS_SCRATCH: Self = Self(3);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BASE_ADDRESS_OUTPUT_ACTIVATION,
    Self::BASE_ADDRESS_INPUT_ACTIVATION,
    Self::BASE_ADDRESS_PARAMETER,
    Self::BASE_ADDRESS_SCRATCH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BASE_ADDRESS_OUTPUT_ACTIVATION => Some("BASE_ADDRESS_OUTPUT_ACTIVATION"),
      Self::BASE_ADDRESS_INPUT_ACTIVATION => Some("BASE_ADDRESS_INPUT_ACTIVATION"),
      Self::BASE_ADDRESS_PARAMETER => Some("BASE_ADDRESS_PARAMETER"),
      Self::BASE_ADDRESS_SCRATCH => Some("BASE_ADDRESS_SCRATCH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Description {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Description {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Description {
    type Output = Description;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Description {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Description {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Description {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_POSITION: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_POSITION: i16 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_POSITION: [Position; 2] = [
  Position::LOWER_32BIT,
  Position::UPPER_32BIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Position(pub i16);
#[allow(non_upper_case_globals)]
impl Position {
  pub const LOWER_32BIT: Self = Self(0);
  pub const UPPER_32BIT: Self = Self(1);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LOWER_32BIT,
    Self::UPPER_32BIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LOWER_32BIT => Some("LOWER_32BIT"),
      Self::UPPER_32BIT => Some("UPPER_32BIT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Position {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Position {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Position {
    type Output = Position;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Position {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Position {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Position {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTERRUPT_TYPE: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTERRUPT_TYPE: i16 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTERRUPT_TYPE: [InterruptType; 4] = [
  InterruptType::SCALAR_CORE_INT_0,
  InterruptType::SCALAR_CORE_INT_1,
  InterruptType::SCALAR_CORE_INT_2,
  InterruptType::SCALAR_CORE_INT_3,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InterruptType(pub i16);
#[allow(non_upper_case_globals)]
impl InterruptType {
  pub const SCALAR_CORE_INT_0: Self = Self(0);
  pub const SCALAR_CORE_INT_1: Self = Self(1);
  pub const SCALAR_CORE_INT_2: Self = Self(2);
  pub const SCALAR_CORE_INT_3: Self = Self(3);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCALAR_CORE_INT_0,
    Self::SCALAR_CORE_INT_1,
    Self::SCALAR_CORE_INT_2,
    Self::SCALAR_CORE_INT_3,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SCALAR_CORE_INT_0 => Some("SCALAR_CORE_INT_0"),
      Self::SCALAR_CORE_INT_1 => Some("SCALAR_CORE_INT_1"),
      Self::SCALAR_CORE_INT_2 => Some("SCALAR_CORE_INT_2"),
      Self::SCALAR_CORE_INT_3 => Some("SCALAR_CORE_INT_3"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for InterruptType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InterruptType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for InterruptType {
    type Output = InterruptType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for InterruptType {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InterruptType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InterruptType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIRECTION: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIRECTION: i16 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTION: [Direction; 2] = [
  Direction::INFEED,
  Direction::OUTFEED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Direction(pub i16);
#[allow(non_upper_case_globals)]
impl Direction {
  pub const INFEED: Self = Self(0);
  pub const OUTFEED: Self = Self(1);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INFEED,
    Self::OUTFEED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::INFEED => Some("INFEED"),
      Self::OUTFEED => Some("OUTFEED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Direction {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Direction {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Direction {
    type Output = Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Direction {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Direction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Direction {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY_HINT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY_HINT: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY_HINT: [AnyHint; 5] = [
  AnyHint::NONE,
  AnyHint::DmaDescriptorHint,
  AnyHint::InstructionHint,
  AnyHint::InterruptHint,
  AnyHint::FenceHint,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnyHint(pub u8);
#[allow(non_upper_case_globals)]
impl AnyHint {
  pub const NONE: Self = Self(0);
  pub const DmaDescriptorHint: Self = Self(1);
  pub const InstructionHint: Self = Self(2);
  pub const InterruptHint: Self = Self(3);
  pub const FenceHint: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DmaDescriptorHint,
    Self::InstructionHint,
    Self::InterruptHint,
    Self::FenceHint,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DmaDescriptorHint => Some("DmaDescriptorHint"),
      Self::InstructionHint => Some("InstructionHint"),
      Self::InterruptHint => Some("InterruptHint"),
      Self::FenceHint => Some("FenceHint"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AnyHint {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AnyHint {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AnyHint {
    type Output = AnyHint;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AnyHint {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AnyHint {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AnyHint {}
pub struct AnyHintUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_TYPE: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_TYPE: i16 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 8] = [
  DataType::FIXED_POINT8,
  DataType::FIXED_POINT16,
  DataType::SIGNED_FIXED_POINT32,
  DataType::BFLOAT,
  DataType::HALF,
  DataType::SINGLE,
  DataType::SIGNED_FIXED_POINT8,
  DataType::SIGNED_FIXED_POINT16,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i16);
#[allow(non_upper_case_globals)]
impl DataType {
  pub const FIXED_POINT8: Self = Self(0);
  pub const FIXED_POINT16: Self = Self(1);
  pub const SIGNED_FIXED_POINT32: Self = Self(2);
  pub const BFLOAT: Self = Self(3);
  pub const HALF: Self = Self(4);
  pub const SINGLE: Self = Self(5);
  pub const SIGNED_FIXED_POINT8: Self = Self(8);
  pub const SIGNED_FIXED_POINT16: Self = Self(9);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FIXED_POINT8,
    Self::FIXED_POINT16,
    Self::SIGNED_FIXED_POINT32,
    Self::BFLOAT,
    Self::HALF,
    Self::SINGLE,
    Self::SIGNED_FIXED_POINT8,
    Self::SIGNED_FIXED_POINT16,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FIXED_POINT8 => Some("FIXED_POINT8"),
      Self::FIXED_POINT16 => Some("FIXED_POINT16"),
      Self::SIGNED_FIXED_POINT32 => Some("SIGNED_FIXED_POINT32"),
      Self::BFLOAT => Some("BFLOAT"),
      Self::HALF => Some("HALF"),
      Self::SINGLE => Some("SINGLE"),
      Self::SIGNED_FIXED_POINT8 => Some("SIGNED_FIXED_POINT8"),
      Self::SIGNED_FIXED_POINT16 => Some("SIGNED_FIXED_POINT16"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataType {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY_LAYER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY_LAYER: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY_LAYER: [AnyLayer; 3] = [
  AnyLayer::NONE,
  AnyLayer::OutputLayer,
  AnyLayer::InputLayer,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnyLayer(pub u8);
#[allow(non_upper_case_globals)]
impl AnyLayer {
  pub const NONE: Self = Self(0);
  pub const OutputLayer: Self = Self(1);
  pub const InputLayer: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::OutputLayer,
    Self::InputLayer,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::OutputLayer => Some("OutputLayer"),
      Self::InputLayer => Some("InputLayer"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AnyLayer {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AnyLayer {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AnyLayer {
    type Output = AnyLayer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AnyLayer {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AnyLayer {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AnyLayer {}
pub struct AnyLayerUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EXECUTABLE_TYPE: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EXECUTABLE_TYPE: i16 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXECUTABLE_TYPE: [ExecutableType; 3] = [
  ExecutableType::STAND_ALONE,
  ExecutableType::PARAMETER_CACHING,
  ExecutableType::EXECUTION_ONLY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExecutableType(pub i16);
#[allow(non_upper_case_globals)]
impl ExecutableType {
  pub const STAND_ALONE: Self = Self(0);
  pub const PARAMETER_CACHING: Self = Self(1);
  pub const EXECUTION_ONLY: Self = Self(2);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STAND_ALONE,
    Self::PARAMETER_CACHING,
    Self::EXECUTION_ONLY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STAND_ALONE => Some("STAND_ALONE"),
      Self::PARAMETER_CACHING => Some("PARAMETER_CACHING"),
      Self::EXECUTION_ONLY => Some("EXECUTION_ONLY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ExecutableType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ExecutableType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ExecutableType {
    type Output = ExecutableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ExecutableType {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ExecutableType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ExecutableType {}
// struct Range, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Range(pub [u8; 8]);
impl Default for Range { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Range {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Range")
      .field("start", &self.start())
      .field("end", &self.end())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Range {}
impl<'a> flatbuffers::Follow<'a> for Range {
  type Inner = &'a Range;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Range>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Range {
  type Inner = &'a Range;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Range>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Range {
    type Output = Range;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Range as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Range {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Range {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    start: i32,
    end: i32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_start(start);
    s.set_end(end);
    s
  }

  pub fn start(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_start(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn end(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_end(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum MetaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Meta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Meta<'a> {
  type Inner = Meta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Meta<'a> {
  pub const VT_DESC: flatbuffers::VOffsetT = 4;
  pub const VT_BATCH: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_POSITION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Meta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MetaArgs<'args>
  ) -> flatbuffers::WIPOffset<Meta<'bldr>> {
    let mut builder = MetaBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_batch(args.batch);
    builder.add_position(args.position);
    builder.add_desc(args.desc);
    builder.finish()
  }


  #[inline]
  pub fn desc(&self) -> Description {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Description>(Meta::VT_DESC, Some(Description::BASE_ADDRESS_OUTPUT_ACTIVATION)).unwrap()}
  }
  #[inline]
  pub fn batch(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Meta::VT_BATCH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Meta::VT_NAME, None)}
  }
  #[inline]
  pub fn position(&self) -> Position {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Position>(Meta::VT_POSITION, Some(Position::LOWER_32BIT)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Meta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Description>("desc", Self::VT_DESC, false)?
     .visit_field::<i32>("batch", Self::VT_BATCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<Position>("position", Self::VT_POSITION, false)?
     .finish();
    Ok(())
  }
}
pub struct MetaArgs<'a> {
    pub desc: Description,
    pub batch: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Position,
}
impl<'a> Default for MetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetaArgs {
      desc: Description::BASE_ADDRESS_OUTPUT_ACTIVATION,
      batch: 0,
      name: None,
      position: Position::LOWER_32BIT,
    }
  }
}

pub struct MetaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetaBuilder<'a, 'b> {
  #[inline]
  pub fn add_desc(&mut self, desc: Description) {
    self.fbb_.push_slot::<Description>(Meta::VT_DESC, desc, Description::BASE_ADDRESS_OUTPUT_ACTIVATION);
  }
  #[inline]
  pub fn add_batch(&mut self, batch: i32) {
    self.fbb_.push_slot::<i32>(Meta::VT_BATCH, batch, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Meta::VT_NAME, name);
  }
  #[inline]
  pub fn add_position(&mut self, position: Position) {
    self.fbb_.push_slot::<Position>(Meta::VT_POSITION, position, Position::LOWER_32BIT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Meta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Meta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Meta");
      ds.field("desc", &self.desc());
      ds.field("batch", &self.batch());
      ds.field("name", &self.name());
      ds.field("position", &self.position());
      ds.finish()
  }
}
pub enum FieldOffsetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FieldOffset<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FieldOffset<'a> {
  type Inner = FieldOffset<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FieldOffset<'a> {
  pub const VT_META: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET_BIT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FieldOffset { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FieldOffsetArgs<'args>
  ) -> flatbuffers::WIPOffset<FieldOffset<'bldr>> {
    let mut builder = FieldOffsetBuilder::new(_fbb);
    builder.add_offset_bit(args.offset_bit);
    if let Some(x) = args.meta { builder.add_meta(x); }
    builder.finish()
  }


  #[inline]
  pub fn meta(&self) -> Option<Meta<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Meta>>(FieldOffset::VT_META, None)}
  }
  #[inline]
  pub fn offset_bit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(FieldOffset::VT_OFFSET_BIT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FieldOffset<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Meta>>("meta", Self::VT_META, false)?
     .visit_field::<i32>("offset_bit", Self::VT_OFFSET_BIT, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldOffsetArgs<'a> {
    pub meta: Option<flatbuffers::WIPOffset<Meta<'a>>>,
    pub offset_bit: i32,
}
impl<'a> Default for FieldOffsetArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldOffsetArgs {
      meta: None,
      offset_bit: 0,
    }
  }
}

pub struct FieldOffsetBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldOffsetBuilder<'a, 'b> {
  #[inline]
  pub fn add_meta(&mut self, meta: flatbuffers::WIPOffset<Meta<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Meta>>(FieldOffset::VT_META, meta);
  }
  #[inline]
  pub fn add_offset_bit(&mut self, offset_bit: i32) {
    self.fbb_.push_slot::<i32>(FieldOffset::VT_OFFSET_BIT, offset_bit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldOffsetBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldOffsetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FieldOffset<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FieldOffset<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FieldOffset");
      ds.field("meta", &self.meta());
      ds.field("offset_bit", &self.offset_bit());
      ds.finish()
  }
}
pub enum InstructionBitstreamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InstructionBitstream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InstructionBitstream<'a> {
  type Inner = InstructionBitstream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InstructionBitstream<'a> {
  pub const VT_BITSTREAM: flatbuffers::VOffsetT = 4;
  pub const VT_FIELD_OFFSETS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InstructionBitstream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InstructionBitstreamArgs<'args>
  ) -> flatbuffers::WIPOffset<InstructionBitstream<'bldr>> {
    let mut builder = InstructionBitstreamBuilder::new(_fbb);
    if let Some(x) = args.field_offsets { builder.add_field_offsets(x); }
    if let Some(x) = args.bitstream { builder.add_bitstream(x); }
    builder.finish()
  }


  #[inline]
  pub fn bitstream(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(InstructionBitstream::VT_BITSTREAM, None)}
  }
  #[inline]
  pub fn field_offsets(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FieldOffset<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FieldOffset>>>>(InstructionBitstream::VT_FIELD_OFFSETS, None)}
  }
}

impl flatbuffers::Verifiable for InstructionBitstream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("bitstream", Self::VT_BITSTREAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FieldOffset>>>>("field_offsets", Self::VT_FIELD_OFFSETS, false)?
     .finish();
    Ok(())
  }
}
pub struct InstructionBitstreamArgs<'a> {
    pub bitstream: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub field_offsets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FieldOffset<'a>>>>>,
}
impl<'a> Default for InstructionBitstreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    InstructionBitstreamArgs {
      bitstream: None,
      field_offsets: None,
    }
  }
}

pub struct InstructionBitstreamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstructionBitstreamBuilder<'a, 'b> {
  #[inline]
  pub fn add_bitstream(&mut self, bitstream: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstructionBitstream::VT_BITSTREAM, bitstream);
  }
  #[inline]
  pub fn add_field_offsets(&mut self, field_offsets: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FieldOffset<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InstructionBitstream::VT_FIELD_OFFSETS, field_offsets);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstructionBitstreamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstructionBitstreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InstructionBitstream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InstructionBitstream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InstructionBitstream");
      ds.field("bitstream", &self.bitstream());
      ds.field("field_offsets", &self.field_offsets());
      ds.finish()
  }
}
pub enum DmaDescriptorHintOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DmaDescriptorHint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DmaDescriptorHint<'a> {
  type Inner = DmaDescriptorHint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DmaDescriptorHint<'a> {
  pub const VT_META: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET_IN_BYTES: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_IN_BYTES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DmaDescriptorHint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DmaDescriptorHintArgs<'args>
  ) -> flatbuffers::WIPOffset<DmaDescriptorHint<'bldr>> {
    let mut builder = DmaDescriptorHintBuilder::new(_fbb);
    builder.add_size_in_bytes(args.size_in_bytes);
    builder.add_offset_in_bytes(args.offset_in_bytes);
    if let Some(x) = args.meta { builder.add_meta(x); }
    builder.finish()
  }


  #[inline]
  pub fn meta(&self) -> Option<Meta<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Meta>>(DmaDescriptorHint::VT_META, None)}
  }
  #[inline]
  pub fn offset_in_bytes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DmaDescriptorHint::VT_OFFSET_IN_BYTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_in_bytes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DmaDescriptorHint::VT_SIZE_IN_BYTES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DmaDescriptorHint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Meta>>("meta", Self::VT_META, false)?
     .visit_field::<i32>("offset_in_bytes", Self::VT_OFFSET_IN_BYTES, false)?
     .visit_field::<i32>("size_in_bytes", Self::VT_SIZE_IN_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct DmaDescriptorHintArgs<'a> {
    pub meta: Option<flatbuffers::WIPOffset<Meta<'a>>>,
    pub offset_in_bytes: i32,
    pub size_in_bytes: i32,
}
impl<'a> Default for DmaDescriptorHintArgs<'a> {
  #[inline]
  fn default() -> Self {
    DmaDescriptorHintArgs {
      meta: None,
      offset_in_bytes: 0,
      size_in_bytes: 0,
    }
  }
}

pub struct DmaDescriptorHintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DmaDescriptorHintBuilder<'a, 'b> {
  #[inline]
  pub fn add_meta(&mut self, meta: flatbuffers::WIPOffset<Meta<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Meta>>(DmaDescriptorHint::VT_META, meta);
  }
  #[inline]
  pub fn add_offset_in_bytes(&mut self, offset_in_bytes: i32) {
    self.fbb_.push_slot::<i32>(DmaDescriptorHint::VT_OFFSET_IN_BYTES, offset_in_bytes, 0);
  }
  #[inline]
  pub fn add_size_in_bytes(&mut self, size_in_bytes: i32) {
    self.fbb_.push_slot::<i32>(DmaDescriptorHint::VT_SIZE_IN_BYTES, size_in_bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DmaDescriptorHintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DmaDescriptorHintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DmaDescriptorHint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DmaDescriptorHint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DmaDescriptorHint");
      ds.field("meta", &self.meta());
      ds.field("offset_in_bytes", &self.offset_in_bytes());
      ds.field("size_in_bytes", &self.size_in_bytes());
      ds.finish()
  }
}
pub enum InterruptHintOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InterruptHint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InterruptHint<'a> {
  type Inner = InterruptHint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InterruptHint<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InterruptHint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InterruptHintArgs
  ) -> flatbuffers::WIPOffset<InterruptHint<'bldr>> {
    let mut builder = InterruptHintBuilder::new(_fbb);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> InterruptType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<InterruptType>(InterruptHint::VT_TYPE_, Some(InterruptType::SCALAR_CORE_INT_0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for InterruptHint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<InterruptType>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct InterruptHintArgs {
    pub type_: InterruptType,
}
impl<'a> Default for InterruptHintArgs {
  #[inline]
  fn default() -> Self {
    InterruptHintArgs {
      type_: InterruptType::SCALAR_CORE_INT_0,
    }
  }
}

pub struct InterruptHintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InterruptHintBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: InterruptType) {
    self.fbb_.push_slot::<InterruptType>(InterruptHint::VT_TYPE_, type_, InterruptType::SCALAR_CORE_INT_0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InterruptHintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InterruptHintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InterruptHint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InterruptHint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InterruptHint");
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum InstructionHintOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InstructionHint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InstructionHint<'a> {
  type Inner = InstructionHint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InstructionHint<'a> {
  pub const VT_INSTRUCTION_CHUNK_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InstructionHint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InstructionHintArgs
  ) -> flatbuffers::WIPOffset<InstructionHint<'bldr>> {
    let mut builder = InstructionHintBuilder::new(_fbb);
    builder.add_instruction_chunk_index(args.instruction_chunk_index);
    builder.finish()
  }


  #[inline]
  pub fn instruction_chunk_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(InstructionHint::VT_INSTRUCTION_CHUNK_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for InstructionHint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("instruction_chunk_index", Self::VT_INSTRUCTION_CHUNK_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct InstructionHintArgs {
    pub instruction_chunk_index: i32,
}
impl<'a> Default for InstructionHintArgs {
  #[inline]
  fn default() -> Self {
    InstructionHintArgs {
      instruction_chunk_index: 0,
    }
  }
}

pub struct InstructionHintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstructionHintBuilder<'a, 'b> {
  #[inline]
  pub fn add_instruction_chunk_index(&mut self, instruction_chunk_index: i32) {
    self.fbb_.push_slot::<i32>(InstructionHint::VT_INSTRUCTION_CHUNK_INDEX, instruction_chunk_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstructionHintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstructionHintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InstructionHint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InstructionHint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InstructionHint");
      ds.field("instruction_chunk_index", &self.instruction_chunk_index());
      ds.finish()
  }
}
pub enum FenceHintOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FenceHint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FenceHint<'a> {
  type Inner = FenceHint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FenceHint<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FenceHint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FenceHintArgs
  ) -> flatbuffers::WIPOffset<FenceHint<'bldr>> {
    let mut builder = FenceHintBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for FenceHint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FenceHintArgs {
}
impl<'a> Default for FenceHintArgs {
  #[inline]
  fn default() -> Self {
    FenceHintArgs {
    }
  }
}

pub struct FenceHintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FenceHintBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FenceHintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FenceHintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FenceHint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FenceHint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FenceHint");
      ds.finish()
  }
}
pub enum DmaHintOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DmaHint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DmaHint<'a> {
  type Inner = DmaHint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DmaHint<'a> {
  pub const VT_ANY_HINT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ANY_HINT: flatbuffers::VOffsetT = 6;
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DmaHint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DmaHintArgs
  ) -> flatbuffers::WIPOffset<DmaHint<'bldr>> {
    let mut builder = DmaHintBuilder::new(_fbb);
    if let Some(x) = args.any_hint { builder.add_any_hint(x); }
    builder.add_direction(args.direction);
    builder.add_any_hint_type(args.any_hint_type);
    builder.finish()
  }


  #[inline]
  pub fn any_hint_type(&self) -> AnyHint {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AnyHint>(DmaHint::VT_ANY_HINT_TYPE, Some(AnyHint::NONE)).unwrap()}
  }
  #[inline]
  pub fn any_hint(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DmaHint::VT_ANY_HINT, None)}
  }
  #[inline]
  pub fn direction(&self) -> Direction {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Direction>(DmaHint::VT_DIRECTION, Some(Direction::INFEED)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn any_hint_as_dma_descriptor_hint(&self) -> Option<DmaDescriptorHint<'a>> {
    if self.any_hint_type() == AnyHint::DmaDescriptorHint {
      self.any_hint().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DmaDescriptorHint::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_hint_as_instruction_hint(&self) -> Option<InstructionHint<'a>> {
    if self.any_hint_type() == AnyHint::InstructionHint {
      self.any_hint().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { InstructionHint::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_hint_as_interrupt_hint(&self) -> Option<InterruptHint<'a>> {
    if self.any_hint_type() == AnyHint::InterruptHint {
      self.any_hint().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { InterruptHint::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_hint_as_fence_hint(&self) -> Option<FenceHint<'a>> {
    if self.any_hint_type() == AnyHint::FenceHint {
      self.any_hint().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FenceHint::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DmaHint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<AnyHint, _>("any_hint_type", Self::VT_ANY_HINT_TYPE, "any_hint", Self::VT_ANY_HINT, false, |key, v, pos| {
        match key {
          AnyHint::DmaDescriptorHint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DmaDescriptorHint>>("AnyHint::DmaDescriptorHint", pos),
          AnyHint::InstructionHint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InstructionHint>>("AnyHint::InstructionHint", pos),
          AnyHint::InterruptHint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InterruptHint>>("AnyHint::InterruptHint", pos),
          AnyHint::FenceHint => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FenceHint>>("AnyHint::FenceHint", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<Direction>("direction", Self::VT_DIRECTION, false)?
     .finish();
    Ok(())
  }
}
pub struct DmaHintArgs {
    pub any_hint_type: AnyHint,
    pub any_hint: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub direction: Direction,
}
impl<'a> Default for DmaHintArgs {
  #[inline]
  fn default() -> Self {
    DmaHintArgs {
      any_hint_type: AnyHint::NONE,
      any_hint: None,
      direction: Direction::INFEED,
    }
  }
}

pub struct DmaHintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DmaHintBuilder<'a, 'b> {
  #[inline]
  pub fn add_any_hint_type(&mut self, any_hint_type: AnyHint) {
    self.fbb_.push_slot::<AnyHint>(DmaHint::VT_ANY_HINT_TYPE, any_hint_type, AnyHint::NONE);
  }
  #[inline]
  pub fn add_any_hint(&mut self, any_hint: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DmaHint::VT_ANY_HINT, any_hint);
  }
  #[inline]
  pub fn add_direction(&mut self, direction: Direction) {
    self.fbb_.push_slot::<Direction>(DmaHint::VT_DIRECTION, direction, Direction::INFEED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DmaHintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DmaHintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DmaHint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DmaHint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DmaHint");
      ds.field("any_hint_type", &self.any_hint_type());
      match self.any_hint_type() {
        AnyHint::DmaDescriptorHint => {
          if let Some(x) = self.any_hint_as_dma_descriptor_hint() {
            ds.field("any_hint", &x)
          } else {
            ds.field("any_hint", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyHint::InstructionHint => {
          if let Some(x) = self.any_hint_as_instruction_hint() {
            ds.field("any_hint", &x)
          } else {
            ds.field("any_hint", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyHint::InterruptHint => {
          if let Some(x) = self.any_hint_as_interrupt_hint() {
            ds.field("any_hint", &x)
          } else {
            ds.field("any_hint", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyHint::FenceHint => {
          if let Some(x) = self.any_hint_as_fence_hint() {
            ds.field("any_hint", &x)
          } else {
            ds.field("any_hint", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_hint", &x)
        },
      };
      ds.field("direction", &self.direction());
      ds.finish()
  }
}
pub enum DmaHintsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DmaHints<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DmaHints<'a> {
  type Inner = DmaHints<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DmaHints<'a> {
  pub const VT_HINTS: flatbuffers::VOffsetT = 4;
  pub const VT_FULLY_DETERMINISTIC: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DmaHints { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DmaHintsArgs<'args>
  ) -> flatbuffers::WIPOffset<DmaHints<'bldr>> {
    let mut builder = DmaHintsBuilder::new(_fbb);
    if let Some(x) = args.hints { builder.add_hints(x); }
    builder.add_fully_deterministic(args.fully_deterministic);
    builder.finish()
  }


  #[inline]
  pub fn hints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DmaHint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DmaHint>>>>(DmaHints::VT_HINTS, None)}
  }
  #[inline]
  pub fn fully_deterministic(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DmaHints::VT_FULLY_DETERMINISTIC, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DmaHints<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DmaHint>>>>("hints", Self::VT_HINTS, false)?
     .visit_field::<bool>("fully_deterministic", Self::VT_FULLY_DETERMINISTIC, false)?
     .finish();
    Ok(())
  }
}
pub struct DmaHintsArgs<'a> {
    pub hints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DmaHint<'a>>>>>,
    pub fully_deterministic: bool,
}
impl<'a> Default for DmaHintsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DmaHintsArgs {
      hints: None,
      fully_deterministic: false,
    }
  }
}

pub struct DmaHintsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DmaHintsBuilder<'a, 'b> {
  #[inline]
  pub fn add_hints(&mut self, hints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DmaHint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DmaHints::VT_HINTS, hints);
  }
  #[inline]
  pub fn add_fully_deterministic(&mut self, fully_deterministic: bool) {
    self.fbb_.push_slot::<bool>(DmaHints::VT_FULLY_DETERMINISTIC, fully_deterministic, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DmaHintsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DmaHintsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DmaHints<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DmaHints<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DmaHints");
      ds.field("hints", &self.hints());
      ds.field("fully_deterministic", &self.fully_deterministic());
      ds.finish()
  }
}
pub enum OutputLayoutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OutputLayout<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputLayout<'a> {
  type Inner = OutputLayout<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OutputLayout<'a> {
  pub const VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP: flatbuffers::VOffsetT = 4;
  pub const VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP: flatbuffers::VOffsetT = 6;
  pub const VT_LINEARIZED_TILE_BYTE_OFFSET: flatbuffers::VOffsetT = 8;
  pub const VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET: flatbuffers::VOffsetT = 10;
  pub const VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET: flatbuffers::VOffsetT = 12;
  pub const VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OutputLayout { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OutputLayoutArgs<'args>
  ) -> flatbuffers::WIPOffset<OutputLayout<'bldr>> {
    let mut builder = OutputLayoutBuilder::new(_fbb);
    if let Some(x) = args.x_coordinate_to_local_y_row_size { builder.add_x_coordinate_to_local_y_row_size(x); }
    if let Some(x) = args.y_coordinate_to_local_y_offset { builder.add_y_coordinate_to_local_y_offset(x); }
    if let Some(x) = args.x_coordinate_to_local_byte_offset { builder.add_x_coordinate_to_local_byte_offset(x); }
    if let Some(x) = args.linearized_tile_byte_offset { builder.add_linearized_tile_byte_offset(x); }
    if let Some(x) = args.x_coordinate_to_linear_tile_id_map { builder.add_x_coordinate_to_linear_tile_id_map(x); }
    if let Some(x) = args.y_coordinate_to_linear_tile_id_map { builder.add_y_coordinate_to_linear_tile_id_map(x); }
    builder.finish()
  }


  #[inline]
  pub fn y_coordinate_to_linear_tile_id_map(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP, None)}
  }
  #[inline]
  pub fn x_coordinate_to_linear_tile_id_map(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP, None)}
  }
  #[inline]
  pub fn linearized_tile_byte_offset(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_LINEARIZED_TILE_BYTE_OFFSET, None)}
  }
  #[inline]
  pub fn x_coordinate_to_local_byte_offset(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET, None)}
  }
  #[inline]
  pub fn y_coordinate_to_local_y_offset(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET, None)}
  }
  #[inline]
  pub fn x_coordinate_to_local_y_row_size(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputLayout::VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE, None)}
  }
}

impl flatbuffers::Verifiable for OutputLayout<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("y_coordinate_to_linear_tile_id_map", Self::VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("x_coordinate_to_linear_tile_id_map", Self::VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("linearized_tile_byte_offset", Self::VT_LINEARIZED_TILE_BYTE_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("x_coordinate_to_local_byte_offset", Self::VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("y_coordinate_to_local_y_offset", Self::VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("x_coordinate_to_local_y_row_size", Self::VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct OutputLayoutArgs<'a> {
    pub y_coordinate_to_linear_tile_id_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub x_coordinate_to_linear_tile_id_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub linearized_tile_byte_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub x_coordinate_to_local_byte_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub y_coordinate_to_local_y_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub x_coordinate_to_local_y_row_size: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OutputLayoutArgs<'a> {
  #[inline]
  fn default() -> Self {
    OutputLayoutArgs {
      y_coordinate_to_linear_tile_id_map: None,
      x_coordinate_to_linear_tile_id_map: None,
      linearized_tile_byte_offset: None,
      x_coordinate_to_local_byte_offset: None,
      y_coordinate_to_local_y_offset: None,
      x_coordinate_to_local_y_row_size: None,
    }
  }
}

pub struct OutputLayoutBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutputLayoutBuilder<'a, 'b> {
  #[inline]
  pub fn add_y_coordinate_to_linear_tile_id_map(&mut self, y_coordinate_to_linear_tile_id_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP, y_coordinate_to_linear_tile_id_map);
  }
  #[inline]
  pub fn add_x_coordinate_to_linear_tile_id_map(&mut self, x_coordinate_to_linear_tile_id_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP, x_coordinate_to_linear_tile_id_map);
  }
  #[inline]
  pub fn add_linearized_tile_byte_offset(&mut self, linearized_tile_byte_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_LINEARIZED_TILE_BYTE_OFFSET, linearized_tile_byte_offset);
  }
  #[inline]
  pub fn add_x_coordinate_to_local_byte_offset(&mut self, x_coordinate_to_local_byte_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET, x_coordinate_to_local_byte_offset);
  }
  #[inline]
  pub fn add_y_coordinate_to_local_y_offset(&mut self, y_coordinate_to_local_y_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET, y_coordinate_to_local_y_offset);
  }
  #[inline]
  pub fn add_x_coordinate_to_local_y_row_size(&mut self, x_coordinate_to_local_y_row_size: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputLayout::VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE, x_coordinate_to_local_y_row_size);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutputLayoutBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutputLayoutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutputLayout<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OutputLayout<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OutputLayout");
      ds.field("y_coordinate_to_linear_tile_id_map", &self.y_coordinate_to_linear_tile_id_map());
      ds.field("x_coordinate_to_linear_tile_id_map", &self.x_coordinate_to_linear_tile_id_map());
      ds.field("linearized_tile_byte_offset", &self.linearized_tile_byte_offset());
      ds.field("x_coordinate_to_local_byte_offset", &self.x_coordinate_to_local_byte_offset());
      ds.field("y_coordinate_to_local_y_offset", &self.y_coordinate_to_local_y_offset());
      ds.field("x_coordinate_to_local_y_row_size", &self.x_coordinate_to_local_y_row_size());
      ds.finish()
  }
}
pub enum TensorShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorShape<'a> {
  type Inner = TensorShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorShape<'a> {
  pub const VT_DIMENSION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorShapeArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorShape<'bldr>> {
    let mut builder = TensorShapeBuilder::new(_fbb);
    if let Some(x) = args.dimension { builder.add_dimension(x); }
    builder.finish()
  }


  #[inline]
  pub fn dimension(&self) -> Option<flatbuffers::Vector<'a, Range>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Range>>>(TensorShape::VT_DIMENSION, None)}
  }
}

impl flatbuffers::Verifiable for TensorShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Range>>>("dimension", Self::VT_DIMENSION, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorShapeArgs<'a> {
    pub dimension: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Range>>>,
}
impl<'a> Default for TensorShapeArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorShapeArgs {
      dimension: None,
    }
  }
}

pub struct TensorShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_dimension(&mut self, dimension: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Range>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorShape::VT_DIMENSION, dimension);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorShape");
      ds.field("dimension", &self.dimension());
      ds.finish()
  }
}
pub enum TensorLayoutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TensorLayout<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TensorLayout<'a> {
  type Inner = TensorLayout<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TensorLayout<'a> {
  pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TensorLayout { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorLayoutArgs<'args>
  ) -> flatbuffers::WIPOffset<TensorLayout<'bldr>> {
    let mut builder = TensorLayoutBuilder::new(_fbb);
    if let Some(x) = args.stride { builder.add_stride(x); }
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.finish()
  }


  #[inline]
  pub fn shape(&self) -> Option<TensorShape<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorShape>>(TensorLayout::VT_SHAPE, None)}
  }
  #[inline]
  pub fn stride(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(TensorLayout::VT_STRIDE, None)}
  }
}

impl flatbuffers::Verifiable for TensorLayout<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorShape>>("shape", Self::VT_SHAPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("stride", Self::VT_STRIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorLayoutArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<TensorShape<'a>>>,
    pub stride: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for TensorLayoutArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorLayoutArgs {
      shape: None,
      stride: None,
    }
  }
}

pub struct TensorLayoutBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorLayoutBuilder<'a, 'b> {
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<TensorShape<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorShape>>(TensorLayout::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_stride(&mut self, stride: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorLayout::VT_STRIDE, stride);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorLayoutBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorLayoutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TensorLayout<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TensorLayout<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TensorLayout");
      ds.field("shape", &self.shape());
      ds.field("stride", &self.stride());
      ds.finish()
  }
}
pub enum OutputShapeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OutputShapeInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputShapeInfo<'a> {
  type Inner = OutputShapeInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OutputShapeInfo<'a> {
  pub const VT_SLICE_LAYOUT: flatbuffers::VOffsetT = 4;
  pub const VT_SLICE_OFFSET: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OutputShapeInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OutputShapeInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<OutputShapeInfo<'bldr>> {
    let mut builder = OutputShapeInfoBuilder::new(_fbb);
    if let Some(x) = args.slice_offset { builder.add_slice_offset(x); }
    if let Some(x) = args.slice_layout { builder.add_slice_layout(x); }
    builder.finish()
  }


  #[inline]
  pub fn slice_layout(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorLayout<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorLayout>>>>(OutputShapeInfo::VT_SLICE_LAYOUT, None)}
  }
  #[inline]
  pub fn slice_offset(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(OutputShapeInfo::VT_SLICE_OFFSET, None)}
  }
}

impl flatbuffers::Verifiable for OutputShapeInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorLayout>>>>("slice_layout", Self::VT_SLICE_LAYOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("slice_offset", Self::VT_SLICE_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct OutputShapeInfoArgs<'a> {
    pub slice_layout: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorLayout<'a>>>>>,
    pub slice_offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OutputShapeInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    OutputShapeInfoArgs {
      slice_layout: None,
      slice_offset: None,
    }
  }
}

pub struct OutputShapeInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutputShapeInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_slice_layout(&mut self, slice_layout: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorLayout<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShapeInfo::VT_SLICE_LAYOUT, slice_layout);
  }
  #[inline]
  pub fn add_slice_offset(&mut self, slice_offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OutputShapeInfo::VT_SLICE_OFFSET, slice_offset);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutputShapeInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutputShapeInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutputShapeInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OutputShapeInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OutputShapeInfo");
      ds.field("slice_layout", &self.slice_layout());
      ds.field("slice_offset", &self.slice_offset());
      ds.finish()
  }
}
pub enum NumericsConstantsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NumericsConstants<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NumericsConstants<'a> {
  type Inner = NumericsConstants<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NumericsConstants<'a> {
  pub const VT_ZERO_POINT: flatbuffers::VOffsetT = 4;
  pub const VT_DEQUANTIZATION_FACTOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NumericsConstants { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NumericsConstantsArgs
  ) -> flatbuffers::WIPOffset<NumericsConstants<'bldr>> {
    let mut builder = NumericsConstantsBuilder::new(_fbb);
    builder.add_dequantization_factor(args.dequantization_factor);
    builder.add_zero_point(args.zero_point);
    builder.finish()
  }


  #[inline]
  pub fn zero_point(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NumericsConstants::VT_ZERO_POINT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dequantization_factor(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NumericsConstants::VT_DEQUANTIZATION_FACTOR, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for NumericsConstants<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("zero_point", Self::VT_ZERO_POINT, false)?
     .visit_field::<f32>("dequantization_factor", Self::VT_DEQUANTIZATION_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct NumericsConstantsArgs {
    pub zero_point: i32,
    pub dequantization_factor: f32,
}
impl<'a> Default for NumericsConstantsArgs {
  #[inline]
  fn default() -> Self {
    NumericsConstantsArgs {
      zero_point: 0,
      dequantization_factor: 0.0,
    }
  }
}

pub struct NumericsConstantsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NumericsConstantsBuilder<'a, 'b> {
  #[inline]
  pub fn add_zero_point(&mut self, zero_point: i32) {
    self.fbb_.push_slot::<i32>(NumericsConstants::VT_ZERO_POINT, zero_point, 0);
  }
  #[inline]
  pub fn add_dequantization_factor(&mut self, dequantization_factor: f32) {
    self.fbb_.push_slot::<f32>(NumericsConstants::VT_DEQUANTIZATION_FACTOR, dequantization_factor, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NumericsConstantsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NumericsConstantsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NumericsConstants<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NumericsConstants<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NumericsConstants");
      ds.field("zero_point", &self.zero_point());
      ds.field("dequantization_factor", &self.dequantization_factor());
      ds.finish()
  }
}
pub enum OutputLayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OutputLayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputLayer<'a> {
  type Inner = OutputLayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OutputLayer<'a> {
  pub const VT_LAYOUT: flatbuffers::VOffsetT = 4;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SHAPE_INFO: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OutputLayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OutputLayerArgs<'args>
  ) -> flatbuffers::WIPOffset<OutputLayer<'bldr>> {
    let mut builder = OutputLayerBuilder::new(_fbb);
    if let Some(x) = args.shape_info { builder.add_shape_info(x); }
    if let Some(x) = args.layout { builder.add_layout(x); }
    builder.add_data_type(args.data_type);
    builder.finish()
  }


  #[inline]
  pub fn layout(&self) -> Option<OutputLayout<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OutputLayout>>(OutputLayer::VT_LAYOUT, None)}
  }
  #[inline]
  pub fn data_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(OutputLayer::VT_DATA_TYPE, Some(DataType::FIXED_POINT8)).unwrap()}
  }
  #[inline]
  pub fn shape_info(&self) -> Option<OutputShapeInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OutputShapeInfo>>(OutputLayer::VT_SHAPE_INFO, None)}
  }
}

impl flatbuffers::Verifiable for OutputLayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<OutputLayout>>("layout", Self::VT_LAYOUT, false)?
     .visit_field::<DataType>("data_type", Self::VT_DATA_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OutputShapeInfo>>("shape_info", Self::VT_SHAPE_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct OutputLayerArgs<'a> {
    pub layout: Option<flatbuffers::WIPOffset<OutputLayout<'a>>>,
    pub data_type: DataType,
    pub shape_info: Option<flatbuffers::WIPOffset<OutputShapeInfo<'a>>>,
}
impl<'a> Default for OutputLayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    OutputLayerArgs {
      layout: None,
      data_type: DataType::FIXED_POINT8,
      shape_info: None,
    }
  }
}

pub struct OutputLayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutputLayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_layout(&mut self, layout: flatbuffers::WIPOffset<OutputLayout<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OutputLayout>>(OutputLayer::VT_LAYOUT, layout);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: DataType) {
    self.fbb_.push_slot::<DataType>(OutputLayer::VT_DATA_TYPE, data_type, DataType::FIXED_POINT8);
  }
  #[inline]
  pub fn add_shape_info(&mut self, shape_info: flatbuffers::WIPOffset<OutputShapeInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OutputShapeInfo>>(OutputLayer::VT_SHAPE_INFO, shape_info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutputLayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutputLayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutputLayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OutputLayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OutputLayer");
      ds.field("layout", &self.layout());
      ds.field("data_type", &self.data_type());
      ds.field("shape_info", &self.shape_info());
      ds.finish()
  }
}
pub enum InputLayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InputLayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InputLayer<'a> {
  type Inner = InputLayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InputLayer<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InputLayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args InputLayerArgs
  ) -> flatbuffers::WIPOffset<InputLayer<'bldr>> {
    let mut builder = InputLayerBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for InputLayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct InputLayerArgs {
}
impl<'a> Default for InputLayerArgs {
  #[inline]
  fn default() -> Self {
    InputLayerArgs {
    }
  }
}

pub struct InputLayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InputLayerBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InputLayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InputLayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InputLayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InputLayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InputLayer");
      ds.finish()
  }
}
pub enum LayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Layer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Layer<'a> {
  type Inner = Layer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Layer<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_BYTES: flatbuffers::VOffsetT = 6;
  pub const VT_Y_DIM: flatbuffers::VOffsetT = 8;
  pub const VT_X_DIM: flatbuffers::VOffsetT = 10;
  pub const VT_Z_DIM: flatbuffers::VOffsetT = 12;
  pub const VT_NUMERICS: flatbuffers::VOffsetT = 14;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 16;
  pub const VT_ANY_LAYER_TYPE: flatbuffers::VOffsetT = 18;
  pub const VT_ANY_LAYER: flatbuffers::VOffsetT = 20;
  pub const VT_EXECUTION_COUNT_PER_INFERENCE: flatbuffers::VOffsetT = 22;
  pub const VT_CACHE_ON_DRAM: flatbuffers::VOffsetT = 24;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Layer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LayerArgs<'args>
  ) -> flatbuffers::WIPOffset<Layer<'bldr>> {
    let mut builder = LayerBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_execution_count_per_inference(args.execution_count_per_inference);
    if let Some(x) = args.any_layer { builder.add_any_layer(x); }
    if let Some(x) = args.numerics { builder.add_numerics(x); }
    builder.add_z_dim(args.z_dim);
    builder.add_x_dim(args.x_dim);
    builder.add_y_dim(args.y_dim);
    builder.add_size_bytes(args.size_bytes);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_data_type(args.data_type);
    builder.add_cache_on_dram(args.cache_on_dram);
    builder.add_any_layer_type(args.any_layer_type);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Layer::VT_NAME, None)}
  }
  #[inline]
  pub fn size_bytes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Layer::VT_SIZE_BYTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn y_dim(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Layer::VT_Y_DIM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x_dim(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Layer::VT_X_DIM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn z_dim(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Layer::VT_Z_DIM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn numerics(&self) -> Option<NumericsConstants<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<NumericsConstants>>(Layer::VT_NUMERICS, None)}
  }
  #[inline]
  pub fn data_type(&self) -> DataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataType>(Layer::VT_DATA_TYPE, Some(DataType::FIXED_POINT8)).unwrap()}
  }
  #[inline]
  pub fn any_layer_type(&self) -> AnyLayer {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AnyLayer>(Layer::VT_ANY_LAYER_TYPE, Some(AnyLayer::NONE)).unwrap()}
  }
  #[inline]
  pub fn any_layer(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Layer::VT_ANY_LAYER, None)}
  }
  #[inline]
  pub fn execution_count_per_inference(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Layer::VT_EXECUTION_COUNT_PER_INFERENCE, Some(1)).unwrap()}
  }
  #[inline]
  pub fn cache_on_dram(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Layer::VT_CACHE_ON_DRAM, Some(false)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<TensorShape<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TensorShape>>(Layer::VT_SHAPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn any_layer_as_output_layer(&self) -> Option<OutputLayer<'a>> {
    if self.any_layer_type() == AnyLayer::OutputLayer {
      self.any_layer().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OutputLayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn any_layer_as_input_layer(&self) -> Option<InputLayer<'a>> {
    if self.any_layer_type() == AnyLayer::InputLayer {
      self.any_layer().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { InputLayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Layer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("size_bytes", Self::VT_SIZE_BYTES, false)?
     .visit_field::<i32>("y_dim", Self::VT_Y_DIM, false)?
     .visit_field::<i32>("x_dim", Self::VT_X_DIM, false)?
     .visit_field::<i32>("z_dim", Self::VT_Z_DIM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<NumericsConstants>>("numerics", Self::VT_NUMERICS, false)?
     .visit_field::<DataType>("data_type", Self::VT_DATA_TYPE, false)?
     .visit_union::<AnyLayer, _>("any_layer_type", Self::VT_ANY_LAYER_TYPE, "any_layer", Self::VT_ANY_LAYER, false, |key, v, pos| {
        match key {
          AnyLayer::OutputLayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OutputLayer>>("AnyLayer::OutputLayer", pos),
          AnyLayer::InputLayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InputLayer>>("AnyLayer::InputLayer", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i32>("execution_count_per_inference", Self::VT_EXECUTION_COUNT_PER_INFERENCE, false)?
     .visit_field::<bool>("cache_on_dram", Self::VT_CACHE_ON_DRAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TensorShape>>("shape", Self::VT_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct LayerArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size_bytes: i32,
    pub y_dim: i32,
    pub x_dim: i32,
    pub z_dim: i32,
    pub numerics: Option<flatbuffers::WIPOffset<NumericsConstants<'a>>>,
    pub data_type: DataType,
    pub any_layer_type: AnyLayer,
    pub any_layer: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub execution_count_per_inference: i32,
    pub cache_on_dram: bool,
    pub shape: Option<flatbuffers::WIPOffset<TensorShape<'a>>>,
}
impl<'a> Default for LayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    LayerArgs {
      name: None,
      size_bytes: 0,
      y_dim: 0,
      x_dim: 0,
      z_dim: 0,
      numerics: None,
      data_type: DataType::FIXED_POINT8,
      any_layer_type: AnyLayer::NONE,
      any_layer: None,
      execution_count_per_inference: 1,
      cache_on_dram: false,
      shape: None,
    }
  }
}

pub struct LayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Layer::VT_NAME, name);
  }
  #[inline]
  pub fn add_size_bytes(&mut self, size_bytes: i32) {
    self.fbb_.push_slot::<i32>(Layer::VT_SIZE_BYTES, size_bytes, 0);
  }
  #[inline]
  pub fn add_y_dim(&mut self, y_dim: i32) {
    self.fbb_.push_slot::<i32>(Layer::VT_Y_DIM, y_dim, 0);
  }
  #[inline]
  pub fn add_x_dim(&mut self, x_dim: i32) {
    self.fbb_.push_slot::<i32>(Layer::VT_X_DIM, x_dim, 0);
  }
  #[inline]
  pub fn add_z_dim(&mut self, z_dim: i32) {
    self.fbb_.push_slot::<i32>(Layer::VT_Z_DIM, z_dim, 0);
  }
  #[inline]
  pub fn add_numerics(&mut self, numerics: flatbuffers::WIPOffset<NumericsConstants<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NumericsConstants>>(Layer::VT_NUMERICS, numerics);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: DataType) {
    self.fbb_.push_slot::<DataType>(Layer::VT_DATA_TYPE, data_type, DataType::FIXED_POINT8);
  }
  #[inline]
  pub fn add_any_layer_type(&mut self, any_layer_type: AnyLayer) {
    self.fbb_.push_slot::<AnyLayer>(Layer::VT_ANY_LAYER_TYPE, any_layer_type, AnyLayer::NONE);
  }
  #[inline]
  pub fn add_any_layer(&mut self, any_layer: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Layer::VT_ANY_LAYER, any_layer);
  }
  #[inline]
  pub fn add_execution_count_per_inference(&mut self, execution_count_per_inference: i32) {
    self.fbb_.push_slot::<i32>(Layer::VT_EXECUTION_COUNT_PER_INFERENCE, execution_count_per_inference, 1);
  }
  #[inline]
  pub fn add_cache_on_dram(&mut self, cache_on_dram: bool) {
    self.fbb_.push_slot::<bool>(Layer::VT_CACHE_ON_DRAM, cache_on_dram, false);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<TensorShape<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TensorShape>>(Layer::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Layer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Layer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Layer");
      ds.field("name", &self.name());
      ds.field("size_bytes", &self.size_bytes());
      ds.field("y_dim", &self.y_dim());
      ds.field("x_dim", &self.x_dim());
      ds.field("z_dim", &self.z_dim());
      ds.field("numerics", &self.numerics());
      ds.field("data_type", &self.data_type());
      ds.field("any_layer_type", &self.any_layer_type());
      match self.any_layer_type() {
        AnyLayer::OutputLayer => {
          if let Some(x) = self.any_layer_as_output_layer() {
            ds.field("any_layer", &x)
          } else {
            ds.field("any_layer", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyLayer::InputLayer => {
          if let Some(x) = self.any_layer_as_input_layer() {
            ds.field("any_layer", &x)
          } else {
            ds.field("any_layer", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("any_layer", &x)
        },
      };
      ds.field("execution_count_per_inference", &self.execution_count_per_inference());
      ds.field("cache_on_dram", &self.cache_on_dram());
      ds.field("shape", &self.shape());
      ds.finish()
  }
}
pub enum ExecutableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Executable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Executable<'a> {
  type Inner = Executable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Executable<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SERIALIZED_MODEL: flatbuffers::VOffsetT = 8;
  pub const VT_BATCH_SIZE: flatbuffers::VOffsetT = 10;
  pub const VT_SCRATCH_SIZE_BYTES: flatbuffers::VOffsetT = 12;
  pub const VT_INSTRUCTION_BITSTREAMS: flatbuffers::VOffsetT = 14;
  pub const VT_PARAMETERS: flatbuffers::VOffsetT = 16;
  pub const VT_DMA_HINTS: flatbuffers::VOffsetT = 18;
  pub const VT_INPUT_LAYERS: flatbuffers::VOffsetT = 20;
  pub const VT_OUTPUT_LAYERS: flatbuffers::VOffsetT = 22;
  pub const VT_CHIP: flatbuffers::VOffsetT = 24;
  pub const VT_ESTIMATED_CYCLES: flatbuffers::VOffsetT = 26;
  pub const VT_USED_NARROW_MEMORY_BYTES_PER_TILE: flatbuffers::VOffsetT = 28;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 30;
  pub const VT_PARAMETER_CACHING_TOKEN: flatbuffers::VOffsetT = 32;
  pub const VT_USE_TPU_DRAM_FOR_PARAMETERS: flatbuffers::VOffsetT = 34;
  pub const VT_ESTIMATED_CYCLES_64BIT: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Executable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExecutableArgs<'args>
  ) -> flatbuffers::WIPOffset<Executable<'bldr>> {
    let mut builder = ExecutableBuilder::new(_fbb);
    builder.add_estimated_cycles_64bit(args.estimated_cycles_64bit);
    builder.add_parameter_caching_token(args.parameter_caching_token);
    builder.add_used_narrow_memory_bytes_per_tile(args.used_narrow_memory_bytes_per_tile);
    builder.add_estimated_cycles(args.estimated_cycles);
    if let Some(x) = args.chip { builder.add_chip(x); }
    if let Some(x) = args.output_layers { builder.add_output_layers(x); }
    if let Some(x) = args.input_layers { builder.add_input_layers(x); }
    if let Some(x) = args.dma_hints { builder.add_dma_hints(x); }
    if let Some(x) = args.parameters { builder.add_parameters(x); }
    if let Some(x) = args.instruction_bitstreams { builder.add_instruction_bitstreams(x); }
    builder.add_scratch_size_bytes(args.scratch_size_bytes);
    builder.add_batch_size(args.batch_size);
    if let Some(x) = args.serialized_model { builder.add_serialized_model(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_version(args.version);
    builder.add_type_(args.type_);
    builder.add_use_tpu_dram_for_parameters(args.use_tpu_dram_for_parameters);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Executable::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Executable::VT_NAME, None)}
  }
  #[inline]
  pub fn serialized_model(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Executable::VT_SERIALIZED_MODEL, None)}
  }
  #[inline]
  pub fn batch_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Executable::VT_BATCH_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scratch_size_bytes(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Executable::VT_SCRATCH_SIZE_BYTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn instruction_bitstreams(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstructionBitstream<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstructionBitstream>>>>(Executable::VT_INSTRUCTION_BITSTREAMS, None)}
  }
  #[inline]
  pub fn parameters(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Executable::VT_PARAMETERS, None)}
  }
  #[inline]
  pub fn dma_hints(&self) -> Option<DmaHints<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DmaHints>>(Executable::VT_DMA_HINTS, None)}
  }
  #[inline]
  pub fn input_layers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer>>>>(Executable::VT_INPUT_LAYERS, None)}
  }
  #[inline]
  pub fn output_layers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer>>>>(Executable::VT_OUTPUT_LAYERS, None)}
  }
  #[inline]
  pub fn chip(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Executable::VT_CHIP, None)}
  }
  #[inline]
  pub fn estimated_cycles(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Executable::VT_ESTIMATED_CYCLES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn used_narrow_memory_bytes_per_tile(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Executable::VT_USED_NARROW_MEMORY_BYTES_PER_TILE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> ExecutableType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ExecutableType>(Executable::VT_TYPE_, Some(ExecutableType::STAND_ALONE)).unwrap()}
  }
  #[inline]
  pub fn parameter_caching_token(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Executable::VT_PARAMETER_CACHING_TOKEN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn use_tpu_dram_for_parameters(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Executable::VT_USE_TPU_DRAM_FOR_PARAMETERS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn estimated_cycles_64bit(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Executable::VT_ESTIMATED_CYCLES_64BIT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Executable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("serialized_model", Self::VT_SERIALIZED_MODEL, false)?
     .visit_field::<i32>("batch_size", Self::VT_BATCH_SIZE, false)?
     .visit_field::<i32>("scratch_size_bytes", Self::VT_SCRATCH_SIZE_BYTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InstructionBitstream>>>>("instruction_bitstreams", Self::VT_INSTRUCTION_BITSTREAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("parameters", Self::VT_PARAMETERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DmaHints>>("dma_hints", Self::VT_DMA_HINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Layer>>>>("input_layers", Self::VT_INPUT_LAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Layer>>>>("output_layers", Self::VT_OUTPUT_LAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chip", Self::VT_CHIP, false)?
     .visit_field::<i32>("estimated_cycles", Self::VT_ESTIMATED_CYCLES, false)?
     .visit_field::<i32>("used_narrow_memory_bytes_per_tile", Self::VT_USED_NARROW_MEMORY_BYTES_PER_TILE, false)?
     .visit_field::<ExecutableType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u64>("parameter_caching_token", Self::VT_PARAMETER_CACHING_TOKEN, false)?
     .visit_field::<bool>("use_tpu_dram_for_parameters", Self::VT_USE_TPU_DRAM_FOR_PARAMETERS, false)?
     .visit_field::<i64>("estimated_cycles_64bit", Self::VT_ESTIMATED_CYCLES_64BIT, false)?
     .finish();
    Ok(())
  }
}
pub struct ExecutableArgs<'a> {
    pub version: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub serialized_model: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub batch_size: i32,
    pub scratch_size_bytes: i32,
    pub instruction_bitstreams: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InstructionBitstream<'a>>>>>,
    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dma_hints: Option<flatbuffers::WIPOffset<DmaHints<'a>>>,
    pub input_layers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer<'a>>>>>,
    pub output_layers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Layer<'a>>>>>,
    pub chip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub estimated_cycles: i32,
    pub used_narrow_memory_bytes_per_tile: i32,
    pub type_: ExecutableType,
    pub parameter_caching_token: u64,
    pub use_tpu_dram_for_parameters: bool,
    pub estimated_cycles_64bit: i64,
}
impl<'a> Default for ExecutableArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExecutableArgs {
      version: 0,
      name: None,
      serialized_model: None,
      batch_size: 0,
      scratch_size_bytes: 0,
      instruction_bitstreams: None,
      parameters: None,
      dma_hints: None,
      input_layers: None,
      output_layers: None,
      chip: None,
      estimated_cycles: 0,
      used_narrow_memory_bytes_per_tile: 0,
      type_: ExecutableType::STAND_ALONE,
      parameter_caching_token: 0,
      use_tpu_dram_for_parameters: false,
      estimated_cycles_64bit: 0,
    }
  }
}

pub struct ExecutableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecutableBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(Executable::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_NAME, name);
  }
  #[inline]
  pub fn add_serialized_model(&mut self, serialized_model: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_SERIALIZED_MODEL, serialized_model);
  }
  #[inline]
  pub fn add_batch_size(&mut self, batch_size: i32) {
    self.fbb_.push_slot::<i32>(Executable::VT_BATCH_SIZE, batch_size, 0);
  }
  #[inline]
  pub fn add_scratch_size_bytes(&mut self, scratch_size_bytes: i32) {
    self.fbb_.push_slot::<i32>(Executable::VT_SCRATCH_SIZE_BYTES, scratch_size_bytes, 0);
  }
  #[inline]
  pub fn add_instruction_bitstreams(&mut self, instruction_bitstreams: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<InstructionBitstream<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_INSTRUCTION_BITSTREAMS, instruction_bitstreams);
  }
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn add_dma_hints(&mut self, dma_hints: flatbuffers::WIPOffset<DmaHints<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DmaHints>>(Executable::VT_DMA_HINTS, dma_hints);
  }
  #[inline]
  pub fn add_input_layers(&mut self, input_layers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Layer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_INPUT_LAYERS, input_layers);
  }
  #[inline]
  pub fn add_output_layers(&mut self, output_layers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Layer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_OUTPUT_LAYERS, output_layers);
  }
  #[inline]
  pub fn add_chip(&mut self, chip: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Executable::VT_CHIP, chip);
  }
  #[inline]
  pub fn add_estimated_cycles(&mut self, estimated_cycles: i32) {
    self.fbb_.push_slot::<i32>(Executable::VT_ESTIMATED_CYCLES, estimated_cycles, 0);
  }
  #[inline]
  pub fn add_used_narrow_memory_bytes_per_tile(&mut self, used_narrow_memory_bytes_per_tile: i32) {
    self.fbb_.push_slot::<i32>(Executable::VT_USED_NARROW_MEMORY_BYTES_PER_TILE, used_narrow_memory_bytes_per_tile, 0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ExecutableType) {
    self.fbb_.push_slot::<ExecutableType>(Executable::VT_TYPE_, type_, ExecutableType::STAND_ALONE);
  }
  #[inline]
  pub fn add_parameter_caching_token(&mut self, parameter_caching_token: u64) {
    self.fbb_.push_slot::<u64>(Executable::VT_PARAMETER_CACHING_TOKEN, parameter_caching_token, 0);
  }
  #[inline]
  pub fn add_use_tpu_dram_for_parameters(&mut self, use_tpu_dram_for_parameters: bool) {
    self.fbb_.push_slot::<bool>(Executable::VT_USE_TPU_DRAM_FOR_PARAMETERS, use_tpu_dram_for_parameters, false);
  }
  #[inline]
  pub fn add_estimated_cycles_64bit(&mut self, estimated_cycles_64bit: i64) {
    self.fbb_.push_slot::<i64>(Executable::VT_ESTIMATED_CYCLES_64BIT, estimated_cycles_64bit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExecutableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExecutableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Executable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Executable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Executable");
      ds.field("version", &self.version());
      ds.field("name", &self.name());
      ds.field("serialized_model", &self.serialized_model());
      ds.field("batch_size", &self.batch_size());
      ds.field("scratch_size_bytes", &self.scratch_size_bytes());
      ds.field("instruction_bitstreams", &self.instruction_bitstreams());
      ds.field("parameters", &self.parameters());
      ds.field("dma_hints", &self.dma_hints());
      ds.field("input_layers", &self.input_layers());
      ds.field("output_layers", &self.output_layers());
      ds.field("chip", &self.chip());
      ds.field("estimated_cycles", &self.estimated_cycles());
      ds.field("used_narrow_memory_bytes_per_tile", &self.used_narrow_memory_bytes_per_tile());
      ds.field("type_", &self.type_());
      ds.field("parameter_caching_token", &self.parameter_caching_token());
      ds.field("use_tpu_dram_for_parameters", &self.use_tpu_dram_for_parameters());
      ds.field("estimated_cycles_64bit", &self.estimated_cycles_64bit());
      ds.finish()
  }
}
pub enum MultiExecutableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MultiExecutable<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MultiExecutable<'a> {
  type Inner = MultiExecutable<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MultiExecutable<'a> {
  pub const VT_SERIALIZED_EXECUTABLES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MultiExecutable { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MultiExecutableArgs<'args>
  ) -> flatbuffers::WIPOffset<MultiExecutable<'bldr>> {
    let mut builder = MultiExecutableBuilder::new(_fbb);
    if let Some(x) = args.serialized_executables { builder.add_serialized_executables(x); }
    builder.finish()
  }


  #[inline]
  pub fn serialized_executables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MultiExecutable::VT_SERIALIZED_EXECUTABLES, None)}
  }
}

impl flatbuffers::Verifiable for MultiExecutable<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("serialized_executables", Self::VT_SERIALIZED_EXECUTABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct MultiExecutableArgs<'a> {
    pub serialized_executables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MultiExecutableArgs<'a> {
  #[inline]
  fn default() -> Self {
    MultiExecutableArgs {
      serialized_executables: None,
    }
  }
}

pub struct MultiExecutableBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MultiExecutableBuilder<'a, 'b> {
  #[inline]
  pub fn add_serialized_executables(&mut self, serialized_executables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MultiExecutable::VT_SERIALIZED_EXECUTABLES, serialized_executables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MultiExecutableBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MultiExecutableBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MultiExecutable<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MultiExecutable<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MultiExecutable");
      ds.field("serialized_executables", &self.serialized_executables());
      ds.finish()
  }
}
pub enum SerializedPackageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SerializedPackage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SerializedPackage<'a> {
  type Inner = SerializedPackage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SerializedPackage<'a> {
  pub const VT_SERIALIZED_PACKAGE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SerializedPackage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SerializedPackageArgs<'args>
  ) -> flatbuffers::WIPOffset<SerializedPackage<'bldr>> {
    let mut builder = SerializedPackageBuilder::new(_fbb);
    if let Some(x) = args.serialized_package { builder.add_serialized_package(x); }
    builder.finish()
  }


  #[inline]
  pub fn serialized_package(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SerializedPackage::VT_SERIALIZED_PACKAGE, None)}
  }
  pub fn serialized_package_nested_flatbuffer(&'a self) -> Option<Package<'a>> {
    self.serialized_package().map(|data| {
      use flatbuffers::Follow;
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid flatbuffer in this slot
      unsafe { <flatbuffers::ForwardsUOffset<Package<'a>>>::follow(data.bytes(), 0) }
    })
  }
}

impl flatbuffers::Verifiable for SerializedPackage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("serialized_package", Self::VT_SERIALIZED_PACKAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct SerializedPackageArgs<'a> {
    pub serialized_package: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SerializedPackageArgs<'a> {
  #[inline]
  fn default() -> Self {
    SerializedPackageArgs {
      serialized_package: None,
    }
  }
}

pub struct SerializedPackageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SerializedPackageBuilder<'a, 'b> {
  #[inline]
  pub fn add_serialized_package(&mut self, serialized_package: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SerializedPackage::VT_SERIALIZED_PACKAGE, serialized_package);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SerializedPackageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SerializedPackageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SerializedPackage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SerializedPackage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SerializedPackage");
      ds.field("serialized_package", &self.serialized_package());
      ds.finish()
  }
}
pub enum PackageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Package<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Package<'a> {
  type Inner = Package<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Package<'a> {
  pub const VT_MIN_RUNTIME_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_SERIALIZED_MULTI_EXECUTABLE: flatbuffers::VOffsetT = 6;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 8;
  pub const VT_KEYPAIR_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_COMPILER_VERSION: flatbuffers::VOffsetT = 12;
  pub const VT_VIRTUAL_CHIP_ID: flatbuffers::VOffsetT = 14;
  pub const VT_MULTI_CHIP_PACKAGE: flatbuffers::VOffsetT = 16;
  pub const VT_MODEL_IDENTIFIER: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Package { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PackageArgs<'args>
  ) -> flatbuffers::WIPOffset<Package<'bldr>> {
    let mut builder = PackageBuilder::new(_fbb);
    if let Some(x) = args.model_identifier { builder.add_model_identifier(x); }
    if let Some(x) = args.multi_chip_package { builder.add_multi_chip_package(x); }
    builder.add_virtual_chip_id(args.virtual_chip_id);
    if let Some(x) = args.compiler_version { builder.add_compiler_version(x); }
    builder.add_keypair_version(args.keypair_version);
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.serialized_multi_executable { builder.add_serialized_multi_executable(x); }
    builder.add_min_runtime_version(args.min_runtime_version);
    builder.finish()
  }


  #[inline]
  pub fn min_runtime_version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Package::VT_MIN_RUNTIME_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn serialized_multi_executable(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Package::VT_SERIALIZED_MULTI_EXECUTABLE, None)}
  }
  #[inline]
  pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Package::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn keypair_version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Package::VT_KEYPAIR_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn compiler_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_COMPILER_VERSION, None)}
  }
  #[inline]
  pub fn virtual_chip_id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Package::VT_VIRTUAL_CHIP_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn multi_chip_package(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SerializedPackage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SerializedPackage>>>>(Package::VT_MULTI_CHIP_PACKAGE, None)}
  }
  #[inline]
  pub fn model_identifier(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Package::VT_MODEL_IDENTIFIER, None)}
  }
}

impl flatbuffers::Verifiable for Package<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("min_runtime_version", Self::VT_MIN_RUNTIME_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("serialized_multi_executable", Self::VT_SERIALIZED_MULTI_EXECUTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<i32>("keypair_version", Self::VT_KEYPAIR_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("compiler_version", Self::VT_COMPILER_VERSION, false)?
     .visit_field::<i32>("virtual_chip_id", Self::VT_VIRTUAL_CHIP_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SerializedPackage>>>>("multi_chip_package", Self::VT_MULTI_CHIP_PACKAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("model_identifier", Self::VT_MODEL_IDENTIFIER, false)?
     .finish();
    Ok(())
  }
}
pub struct PackageArgs<'a> {
    pub min_runtime_version: i32,
    pub serialized_multi_executable: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub keypair_version: i32,
    pub compiler_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub virtual_chip_id: i32,
    pub multi_chip_package: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SerializedPackage<'a>>>>>,
    pub model_identifier: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PackageArgs<'a> {
  #[inline]
  fn default() -> Self {
    PackageArgs {
      min_runtime_version: 0,
      serialized_multi_executable: None,
      signature: None,
      keypair_version: 0,
      compiler_version: None,
      virtual_chip_id: 0,
      multi_chip_package: None,
      model_identifier: None,
    }
  }
}

pub struct PackageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PackageBuilder<'a, 'b> {
  #[inline]
  pub fn add_min_runtime_version(&mut self, min_runtime_version: i32) {
    self.fbb_.push_slot::<i32>(Package::VT_MIN_RUNTIME_VERSION, min_runtime_version, 0);
  }
  #[inline]
  pub fn add_serialized_multi_executable(&mut self, serialized_multi_executable: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_SERIALIZED_MULTI_EXECUTABLE, serialized_multi_executable);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_keypair_version(&mut self, keypair_version: i32) {
    self.fbb_.push_slot::<i32>(Package::VT_KEYPAIR_VERSION, keypair_version, 0);
  }
  #[inline]
  pub fn add_compiler_version(&mut self, compiler_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_COMPILER_VERSION, compiler_version);
  }
  #[inline]
  pub fn add_virtual_chip_id(&mut self, virtual_chip_id: i32) {
    self.fbb_.push_slot::<i32>(Package::VT_VIRTUAL_CHIP_ID, virtual_chip_id, 0);
  }
  #[inline]
  pub fn add_multi_chip_package(&mut self, multi_chip_package: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SerializedPackage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_MULTI_CHIP_PACKAGE, multi_chip_package);
  }
  #[inline]
  pub fn add_model_identifier(&mut self, model_identifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Package::VT_MODEL_IDENTIFIER, model_identifier);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PackageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Package<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Package<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Package");
      ds.field("min_runtime_version", &self.min_runtime_version());
      ds.field("serialized_multi_executable", &self.serialized_multi_executable());
      ds.field("signature", &self.signature());
      ds.field("keypair_version", &self.keypair_version());
      ds.field("compiler_version", &self.compiler_version());
      ds.field("virtual_chip_id", &self.virtual_chip_id());
      ds.field("multi_chip_package", &self.multi_chip_package());
      ds.field("model_identifier", &self.model_identifier());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Package`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_package_unchecked`.
pub fn root_as_package(buf: &[u8]) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Package>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Package` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_package_unchecked`.
pub fn size_prefixed_root_as_package(buf: &[u8]) -> Result<Package, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Package>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Package` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_package_unchecked`.
pub fn root_as_package_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Package<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Package` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_package_unchecked`.
pub fn size_prefixed_root_as_package_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Package<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Package<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Package and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Package`.
pub unsafe fn root_as_package_unchecked(buf: &[u8]) -> Package {
  flatbuffers::root_unchecked::<Package>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Package and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Package`.
pub unsafe fn size_prefixed_root_as_package_unchecked(buf: &[u8]) -> Package {
  flatbuffers::size_prefixed_root_unchecked::<Package>(buf)
}
pub const PACKAGE_IDENTIFIER: &str = "DWN1";

#[inline]
pub fn package_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PACKAGE_IDENTIFIER, false)
}

#[inline]
pub fn package_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PACKAGE_IDENTIFIER, true)
}

#[inline]
pub fn finish_package_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Package<'a>>) {
  fbb.finish(root, Some(PACKAGE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_package_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Package<'a>>) {
  fbb.finish_size_prefixed(root, Some(PACKAGE_IDENTIFIER));
}
}  // pub mod darwinn
}  // pub mod platforms

